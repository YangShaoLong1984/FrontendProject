### 组件化的理解

> http://static.kancloud.cn/zep-tsang/components/341924
>
> 狭义的组件化一般是指标签化，也就是以自定义标签（自定义属性）为核心的机制。
>
> 广义的组件化包括对数据逻辑层业务梳理，形成不同层级的能力封装。
>
> 对组件的封装都是为了对数据逻辑业务代码的抽象管理，使得不同组件各自完成各自的任务，至于JS组件化的概念，我觉得称之为模块化会更贴切一点。
>
> 不管是CommonJS规范、AMD规范、CMD规范还是ES6的模块机制都是为了让JS更模块化，更加细分每个JS的功能点，按需加载，使得不同功能的业务分离开来，每个模块只要专注于自己的业务逻辑代码，这样不仅开发的时候让攻城更加条理，目录一目了然，后期维护也能快速定位到相应的业务逻辑模块。

### CommonJS、AMD、CMD、UMD、ES6 Module

> https://juejin.cn/post/6994814324548091940
>
> CommonJs用在服务器端，AMD和CMD用在浏览器环境
>  AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
>  CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。\
>
> AMD:提前执行（异步加载：依赖先执行）+延迟执行
>  CMD:延迟执行（运行到需加载，根据顺序执行）
>
> CommonJS时`运行时加载`，因为ComminJS加载是先`加载整个模块，生成一个对象`（这个对象包含了path这个模块的所有API），然后再从这个对象上面读取方法-----运行时加载 
>
> ES6是`编译时加载`，`ES6模块不是对象`，它的对外接口只是一种静态定义，在代码静态定义阶段就会生成-----编译时加载

### jsx转js需要babel的编译转换

