### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

> 滑动窗口
>
> ```js
> var lengthOfLongestSubstring = function(s) {
>     let window = {};
>     let left = 0, right = 0;
>     let res = 0;
>     while (right < s.length) {
>         let cur = s[right++];
>         window[cur] = (window[cur] || 0) + 1;
>         while (window[cur] > 1) {
>             let willRemove = s[left++];
>             window[willRemove]--;
>         }
>         res = Math.max(res, right - left);
>     }
>     return res;
> };
> ```

### [46. 全排列](https://leetcode.cn/problems/permutations/)

> 回溯专题
>
> ```js
> var permute = function(nums) {
>     let path = [];
>     let res = [];
>     let used = new Array(nums.length).fill(false);
>     const backtrack = path => {
>         if (path.length === nums.length) {
>             res.push(Array.from(path));
>         }
>         for (let i = 0; i < nums.length; i++) {
>             if (used[i]) {
>                 continue;
>             }
>             path.push(nums[i]);
>             used[i] = true;
>             backtrack(path);
>             path.pop();
>             used[i] = false;
>         }
>     }
>     backtrack(path);
>     return res;
> };
> ```

### [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/)

> 双指针，时间复杂度：O(n+m)，空间复杂度：O(1)
>
> charCodeAt() 方法可返回指定位置的字符的Unicode 编码，返回值是0 - 65535 之间的整数
>
> ps:赋值那里`x * 10 + version1[i].charCodeAt() - '0'.charCodeAt()`;，乘以10是为了进位，减去`'0'.charCodeAt()`是为了消除前导0的影响。
>
> ```js
> // 双指针解法
> var compareVersion = function(version1, version2) {
>     let i = 0, j = 0;
>     let m = version1.length, n = version2.length;
>     while (i < m || j < n) {
>         let x = 0;
>         for (; i < m && version1[i] != '.'; i++) {     //-------一定要注意，判别条件要加上 i < m
>             x = x * 10 + version1[i].charCodeAt() - '0'.charCodeAt();
>         }
>         i++; // 跳过'.'
>         let y = 0;
>         for (; j < n && version2[j] != '.'; j++) {
>             y = y * 10 + version2[j].charCodeAt() - '0'.charCodeAt();
>         }
>         j++;
>         if (x !== y) {
>             return x > y ? 1 : -1;
>         }
>     }
>     return 0;
> };
> ```
>
> 解法2，时间复杂度：O(n+m),空间复杂度：O(n+m)
>
> ```js
> var compareVersion = function(version1, version2) {
>     let arr1 = version1.split('.');
>     let arr2 = version2.split('.');
>     for (let i = 0; i < arr1.length || i < arr2.length; i++) {
>         let x = 0, y = 0;
>         if (i < arr1.length) {
>             x = parseInt(arr1[i]);
>         }
>         if (i < arr2.length) {
>             y = parseInt(arr2[i]);
>         }
>         if (x !== y) {
>             return x > y ? 1 : -1;
>         }
>     }
>     return 0;
> };	
> ```
>

### 洗牌算法-对数组乱序输出

> https://github.com/ccforward/cc/issues/44
>
> 思路：**每次从未处理的数组中随机取一个元素，然后把该元素放到数组的尾部，即数组的尾部放的就是已经处理过的元素**，这是一种原地打乱的算法，每个元素随机概率也相等，时间复杂度从 Fisher 算法的 O(n2)提升到了 O(n)
>
> 1. 选取数组(长度n)中最后一个元素(arr[length-1])，将其与n个元素中的任意一个交换，此时最后一个元素已经确定
> 2. 选取倒数第二个元素(arr[length-2])，将其与n-1个元素中的任意一个交换
> 3. 重复第 1 2 步，直到剩下1个元素为止
>
> ```js
> function shuffle(arr) {
>     let len = arr.length, random;
>     while (len) {
>         random = Math.floor(Math.random() * len--);
>         [arr[len], arr[random]] = [arr[random], arr[len]];
>     }
>     return arr;
> }
> console.log(shuffle([1, 2, 3, 4, 5])); // [ 5, 1, 4, 2, 3 ]
> ```
>
> ```js
> function shuffle(arr) {
>     let n = arr.length, random;
>     while (0 != n) {
>         random =  (Math.random() * n--) >>> 0; // 无符号右移位运算符向下取整
>         [arr[n], arr[random]] = [arr[random], arr[n]] // ES6的结构赋值实现变量互换
>     }
>     return arr;
> }
> ```
>
> > ps:>>>0 正数向下取整，https://www.cnblogs.com/mtl-key/p/13150674.html

### 912.排序数组 

> https://mp.weixin.qq.com/s/8ZTMhvHJK_He48PpSt_AmQ
>
> ps：加洗牌算法后，速度快了很多
>
> partition` 函数， `partition` 函数的作用是在 `nums[lo..hi]` 中寻找一个分界点 `p`，通过交换元素使得 `nums[lo..p-1]` 都小于等于 `nums[p]`，且 `nums[p+1..hi]` 都大于 `nums[p]，总结来讲，`partition` 函数干的事情，其实就是把 `nums[p]` 这个元素排好序。

> ```js
> var sortArray = function(nums) {
>     // 洗牌算法，最大限度避免极端情况
>     shuffle(nums);
>     quickSort(nums, 0, nums.length - 1);
>     return nums;
> };
> 
> function quickSort(nums, low, high) {
>     if (low >= high) {
>         return;
>     }
>     // 对 nums[low..high] 进行切分
>     // 使得 nums[low..sureIndex] <= nums[sureIndex] < nums[sureIndex+1..high]
>     let sureIndex = partition(nums, low, high);
>     quickSort(nums, low, sureIndex - 1);
>     quickSort(nums, sureIndex + 1, high);
> }
> // 快排核心算法,对 nums[low..high] 进行切分
> function partition(nums, low, high) {
>     let i = low + 1, j = high;
>     let pivot = nums[low];
>     // 关于区间的边界控制需格外小心，稍有不慎就会出错
>     while (i <= j) {
>         while (i < high && nums[i] <= pivot) { // 注意！！！ 加 = // i往右走，直到指向大于pivot的元素，停止，等待交换
>             i++;
>         }
>         while (j > low && nums[j] > pivot) {   // j往左走，直到指向小于pivot的元素，停止，等待交换
>             j--;
>         }
>         if (i >= j) {                           // 此时j指向的是已经排好位置的索引
>             break;
>         }
>         [nums[i], nums[j]] = [nums[j], nums[i]];  // 交换i,j指向的元素，保证以pivot基准，左小右大
>     }
>     // 将 pivot(nums[low]) 放到合适的位置，即 pivot 左边元素较小，右边元素较大
>     [nums[j], nums[low]] = [nums[low], nums[j]];
>     return j;                                  
> }
> 
> // 洗牌算法 实现数组乱序  --- 优化，要不要都行
> function shuffle(nums) {
>     let len = nums.length, random;
>     while(len) {
>         random = parseInt(Math.random() * len--);
>         [nums[len], nums[random]] = [nums[random], nums[len]];
>     }
> }
> ```

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

> 利用快排的partition思想来寻找第k个最大元素
>
> * 在长度为n的排序数组中，第k大的数字的下标是n-k
> * 用快速排序的函数partition对数组分区，如果函数partition选取的中间值在分区之后的下标正好是n-k，分区后左边的的值都比中间值小，右边的值都比中间值大，即使整个数组不是排序的，中间值也肯定是第k大的数字
> * 如果函数partition选取的中间值在分区之后的下标大于n-k，那么第k大的数字一定位于中间值的左侧，于是再对中间值的左侧的子数组分区
> * 如果函数partition选择的中间值在分区之后的下标小于n-k，那么第k大的数字一定位于中间值的右侧，于是再对中间值的右侧的子数组分区
>
> ```js
> var findKthLargest = function(nums, k) {
>     let low = 0, high = nums.length - 1;
>     // 找到数组升序排列中，第k个最大元素的数组下标--我们所求目标值的数组下标
>     let targetIndex = nums.length - k;
>     while (low <= high) {
>         // 在 nums[low...high] 中选一个分界点
>         let index = partition(nums, low, high);
>         if (index > targetIndex) {
>             high = index - 1;
>         } else if (index < targetIndex) {
>             low = index + 1;
>         } else {
>             return nums[targetIndex];
>         }
>     }
>     return -1;
> };
> 
> function partition(nums, low, high) {
>     // 取第一个元素作为基准元素
>     let pivot = nums[low];
>     let i = low + 1, j = high;
>     while (i <= j) {
>         while (i < high && nums[i] <= pivot) {     // i往右走，直到指向大于pivot的元素，停止，等待交换
>             i++;
>         }
>         while (j > low && nums[j] > pivot) {       // j往左走，直到指向小于pivot的元素，停止，等待交换
>             j--;
>         }
>         if (i >= j) {                              // 此时j指向的是已经排好位置的索引
>             break;
>         }
>         [nums[i], nums[j]] = [nums[j], nums[i]];  // 交换i,j指向的元素，保证以pivot基准，左小右大
>     }
>     // 将pivot放到合适位置，即pivot左边元素较小，右边元素较大
>     [nums[low], nums[j]] = [nums[j], nums[low]]
>     return j;
> }
> ```

### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

> 分解问题思路的递归
>
> ```js
> var maxDepth = function(root) {
>     if (root === null) {
>         return 0;
>     }
>     const leftDepth = maxDepth(root.left);
>     const rightDepth = maxDepth(root.right);
>     return Math.max(leftDepth, rightDepth) + 1;
> };
> ```
>
> 回溯版思路的递归
>
> ```js
> var maxDepth = function(root) {
>     let res = 0;
>     let depth = 0;
>     const traverse = root => {
>         if (root === null) {
>             res = Math.max(res, depth);
>             return;
>         }
>         depth++;
>         traverse(root.left);
>         traverse(root.right);
>         depth--;
>     }
>     traverse(root);
>     return res;
> };
> ```

