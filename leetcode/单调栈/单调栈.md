## [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

> 解法1，双层暴力循环
>
> 解法2，单调栈
>
> 但是
>
> * 怎么能想到用单调栈呢？
> * 什么时候用单调栈呢？
>
> **通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**。
>
> 时间复杂度为O(n)。
>
> 例如本题其实就是找到右边第一个比自己大的元素。
>
> 此时就应该想到用单调栈了。
>
> * 那么单调栈的原理是什么呢？
> * 为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？
>
> 单调栈的本质是`空间换时间`：因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是只需要遍历一次。
>
> 在使用单调栈的时候首先要明确如下几点：
>
> 1. 单调栈里存放的元素是什么？
>
> 单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。
>
> 1. 单调栈里元素是递增呢？ 还是递减呢？
>
> **注意一下顺序为 从栈头到栈底的顺序**
>
> 这里我们要使用递增循序（再强调一下是指从栈头到栈底的顺序），`因为只有递增的时候，加入一个元素i，才知道栈顶元素在数组中右面第一个比栈顶元素大的元素是i`。
>
> 文字描述理解起来有点费劲，接下来画了一系列的图，来讲解单调栈的工作过程。
>
> 使用单调栈主要有三个判断条件。
>
> - 当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
> - 当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
> - 当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况
>
> **把这三种情况分析清楚了，也就理解透彻了**。
>
> 接下来用temperatures = [73, 74, 75, 71, 71, 72, 76, 73]为例来逐步分析，输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
>
> 1. 首先先将第一个遍历元素（下标）加入单调栈
>
> <img src="单调栈.assets/image-20220706142837910.png" alt="image-20220706142837910" style="zoom: 50%;" />
>
> 2. 加入T[1] = 74，因为T[1] > T[0]（当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），而我们要保持一个递增单调栈（从栈头到栈底），所以将T[0]弹出，T[1]加入，此时result数组可以记录了，result[0] = 1，即T[0]右面第一个比T[0]大的元素是T[1]。
>
>    <img src="单调栈.assets/image-20220706142914982.png" alt="image-20220706142914982" style="zoom:50%;" />
>
>    3. 加入T[2]，同理，T[1]弹出
>
>    <img src="单调栈.assets/image-20220706143010064.png" alt="image-20220706143010064" style="zoom:50%;" />
>
>    4. 加入T[3]，T[3] < T[2] （当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况），加T[3]加入单调栈。
>
>       <img src="单调栈.assets/image-20220706143051599.png" alt="image-20220706143051599" style="zoom:50%;" />
>
>    5. 加入T[4]，T[4] == T[3] （当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况），此时依然要加入栈，不用计算距离，因为我们要求的是右面第一个大于本元素的位置，而不是大于等于！
>
>    <img src="单调栈.assets/image-20220706143125321.png" alt="image-20220706143125321" style="zoom:50%;" />
>
>    6. 加入T[5]，T[5] > T[4] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[4]弹出，同时计算距离，更新result
>
>    <img src="单调栈.assets/image-20220706143154665.png" alt="image-20220706143154665" style="zoom:50%;" />
>
>    7. T[4]弹出之后， T[5] > T[3] （当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况），将T[3]继续弹出，同时计算距离，更新result
>
>    <img src="单调栈.assets/image-20220706143258782.png" alt="image-20220706143258782" style="zoom:50%;" />
>
>    8. 直到发现T[5]小于T[st.top()]，终止弹出，将T[5]加入单调栈
>
>    <img src="单调栈.assets/image-20220706143328318.png" alt="image-20220706143328318" style="zoom:50%;" />
>
>    9. 加入T[6]，同理，需要将栈里的T[5]，T[2]弹出
>
>    <img src="单调栈.assets/image-20220706143405910.png" alt="image-20220706143405910" style="zoom:50%;" />
>
>    10. 同理，继续弹出
>
>    <img src="单调栈.assets/image-20220706143431623.png" alt="image-20220706143431623" style="zoom:50%;" />
>
>    11. 此时栈里只剩下了T[6]
>
>    <img src="单调栈.assets/image-20220706143452903.png" alt="image-20220706143452903" style="zoom:50%;" />
>
>    12. 加入T[7]， T[7] < T[6] 直接入栈，这就是最后的情况，result数组也更新完了。
>
>    <img src="单调栈.assets/image-20220706143517750.png" alt="image-20220706143517750" style="zoom:50%;" />
>
>    此时有可能就疑惑了，那result[6] , result[7]怎么没更新啊，元素也一直在栈里。
>
>    其实定义result数组的时候，就应该直接初始化为0，如果result没有更新，说明这个元素右面没有更大的了，也就是为0。
>
>    以上在图解的时候，已经把，这三种情况都做了详细的分析。
>
>    - 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
>    - 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
>    - 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况
>
> ```js
> var dailyTemperatures = function(temperatures) {
>     const n = temperatures.length;
>     const res = Array(n).fill(0);
>     const stack = []; // 递增栈，用于存储右边第一个比它大的元素
>     stack.push(0); // 先推入下标0
>     for (let i = 1; i < n; i++) {
>         // 栈顶元素，存的是温度数组的下标
>         const top = stack[stack.length - 1];
>         // 情况一，当前元素小于栈顶所代表的元素
>         if (temperatures[i] < temperatures[top]) {
>             stack.push(i);
>         // 情况二，等于
>         } else if (temperatures[i] === temperatures[top]) {
>             stack.push(i);
>         } else {
>         // 情况三，大于，此时要做操作，保证以栈顶递增
>             while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) {
>                 const top = stack.pop();
>                 res[top] = i - top;
>             }
>             stack.push(i);
>         }
>     }
>     return res;
> };
> ```
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)
>
> 必须要先理解透上面代码，才可以精简代码版本：
>
> ```js
> var dailyTemperatures = function(temperatures) {
>     const n = temperatures.length;
>     const res = Array(n).fill(0);
>     const stack = [];
>     stack.push(0);
>     for (let i = 1; i < n; i++) {
>         while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) {
>             const top = stack.pop();
>             res[top] = i - top;
>         }
>         stack.push(i);
>     }
>     return res;
> };
> ```

## [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

**示例 1：**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

> **两题的比较**
>
> 在[739. 每日温度 (opens new window)](https://programmercarl.com/0739.每日温度.html)中是求每个元素下一个比当前元素大的元素的 位置下标。
>
> 本题则是说 nums1 是 nums2 的子集，找 nums1 中的元素在 nums2 中下一个比当前元素大的元素的 值。
>
> 本题相比上一题绕了一下，首先，要定义一个和nums1一样大小的数组result来存放结果，初始化为-1。
>
> **`本题要额外注意的思路`**
>
> 没有重复元素，我们就可以用map来做映射了。根据数值快速找到下标
>
> `思路`是这样的：
>
> > 1, 还是按照每日温度的思路，只不过在while循环里，我们不需要再求 位置下标 了，而是转用map来保存当前遍历元素的下一个比当前元素更大的元素。但要注意，不是所有元素都会进入while循环，只有满足 情况三 的才会进入while循环，所以对情况一和情况二，没有赋值，不过没关系，接下来给它们赋值 -1
> >
> > 2， 再用for循环遍历 nums1，利用map.get筛选需要的元素，同时，把get中没有的赋值为 -1，原因见上。
>
> >  关于`单调栈`，再重复一遍：
> >
> > 使用单调栈，首先要想单调栈是从大到小还是从小到大。
> >
> > 栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素。其实递减栈就是求右边第一个比自己小的元素了。	
>
> > 接下来就要分析如下`三种情况`，一定要分析清楚。
> >
> > 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况
> >
> > 此时满足递增栈（栈头到栈底的顺序），所以直接入栈。
> >
> > 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况
> >
> > 如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！
> >
> > 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况
> >
> > 此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。
> >
> > 判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。
> >
> > 记录结果这块逻辑有一点小绕，要清楚，此时栈顶元素在nums2中右面第一个大的元素是nums2[i]即当前
>
> ```js
> var nextGreaterElement = function(nums1, nums2) {
>     const stack = [];
>     stack.push(0);
>     const map = new Map();
>     for (let i = 1; i < nums2.length; i++) {
>         while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {
>             const top = stack.pop();
>             map.set(nums2[top], nums2[i]);
>         }
>         stack.push(i);
>     }
>     const res = [];
>     for (let j = 0; j < nums1.length; j++) {
>         res[j] = map.get(nums1[j]) || -1;
>     }
>     return res;
> };
> ```
>
> - 时间复杂度：O(n)
> - 空间复杂度：O(n)